package com.ddf.datastructure.sort;

import java.util.Arrays;

/**
 * 希尔排序
 *
 * 希尔排序是为了解决插入排序如果较小的元素都排在后面，而我们又是按照从小到大的方式排序，
 * 那么必然会造成过多的移位操作，希尔排序是对插入排序的一种优化；
 * 它的核心思想是对一个未排序的数组进行对半切分，然后在切分的数组里进行跳序比较，所以也叫缩小增量排序
 * 它的最优时间复杂度为O(n)，最差则为O(n²),一般介于n的1.3到2平方之间
 *
 * @author dongfang.ding
 * @date 2019/6/27 15:20
 */
public class ShellSort {

    public static void main(String[] args) {
        int[] arr = {30, 15, 18, 17, 12, 15, 14, 13};
        int[] sort = swapSort(arr);
        System.out.println("排序后： " + Arrays.toString(arr));
        System.out.println("排序后： " + Arrays.toString(sort));
    }


    /**
     * 希尔排序
     *
     *
     *  30, 15, 18, 17, 12, 15, 14, 13
     *
     *  交换法：=========================================================
     *
     *  1. gap = 8 / 2 = 4, 每4个比较交换一次
     *      第1次数组内循环,从0开始数4个，逆序就交换
     *          从[0]到[4]: 12, 15, 18, 17, 30, 15, 14, 13
     *          从[4]到[8]: 超出数组长度，跳出循环
     *      第2次数组内循环
     *          从[0]到[4]: 12, 15, 18, 17, 30, 15, 14, 13
     *          从[4]到[8]: 超出数组长度，跳出循环
     *      第3次数组内循环
     *          从[0]到[4]: 12, 15, 14, 17, 30, 15, 18, 13
     *          从[4]到[8]: 超出数组长度，跳出循环
     *      第4次数组内循环
     *          从[0]到[4]: 12, 15, 14, 13, 30, 15, 18, 17
     *          从[4]到[8]: 超出数组长度，跳出循环
     *      循环次数 > gap 跳出外循环
     *
     *  2. gap = 4 / 2 = 2, 每2个比较交换一次
     *      第1次数组内循环，从[0]开始每次数2个，逆序就交换
     *          从[0]到[2]: 12, 15, 14, 13, 30, 15, 18, 17
     *          从[2]到[4]: 12, 15, 14, 13, 30, 15, 18, 17
     *          从[4]到[6]: 12, 15, 14, 13, 18, 15, 30, 17
     *          从[6]到[8]: 超出数组长度，跳出循环
     *      第2次数组内循环，从[1]开始每次数2个，逆序就交换
     *          从[0]到[2]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[2]到[4]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[4]到[6]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[6]到[8]: 超出数组长度，跳出循环
     *      循环次数 > gap 跳出外循环
     *
     *  3. gap = 2 / 2 = 1， 每1个比较交换一次
     *      第1次数组内循环，从[0]开始每次数1个，逆序就交换
     *          从[0]到[1]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[1]到[2]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[2]到[3]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[3]到[4]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[4]到[5]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[5]到[6]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[6]到[7]: 12, 13, 14, 15, 18, 15, 30, 17
     *          从[7]到[8]: 超出数组长度，跳出循环
     *      循环次数 > gap 跳出外循环
     *
     *  4. 排序完成
     *
     *  交换法：=========================================================
     *
     * @author dongfang.ding
     * @date 2019/6/27 15:20
     */
    public static int[] swapSort(int[] arr) {
        // 拷贝数组，不改变原数组的值
        int[] dest = Arrays.copyOf(arr, arr.length);
        int temp;
        // 数组切分方式,每次对半切分
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            // 切分的数组个数，切分成几个数组，就循环几次
            for (int i = 0; i <= gap; i ++) {
                // 数组切分好之后，数组内按照gap跳着两两比较，发现逆序就交换
                for (int j = i; j < dest.length - gap; j += gap) {
                    if (dest[j] > dest[j + gap]) {
                        temp = dest[j];
                        dest[j] = dest[j + gap];
                        dest[j + gap] = temp;
                    }
                }
            }
        }
        return dest;
    }
}
